
import csv
import sys
import os
import zipfile
import io

def convert_wcvp():
    # Detect Project Root (one level up from this script in /scripts)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    root_dir = os.path.dirname(script_dir)
    
    # Configuration using Absolute Paths
    INPUT_DIR = os.path.join(root_dir, 'data', 'input')
    TEMP_DIR = os.path.join(root_dir, 'data', 'temp')
    OUTPUT_FILENAME = os.path.join(TEMP_DIR, 'wcvp_names_clean.csv')
    
    # Filenames typically found inside the Kew ZIP or provided directly
    CANDIDATE_NAMES = ['wcvp_names.csv', 'wcvp_names.txt', 'checklist_names.txt']

    source_file = None
    is_zip = False
    zip_archive = None

    print(f"Project Root: {root_dir}")

    # Ensure temp directory exists
    if not os.path.exists(TEMP_DIR):
        try:
            os.makedirs(TEMP_DIR, exist_ok=True)
            print(f"Created directory: {TEMP_DIR}")
        except Exception as e:
            print(f"Error creating temp directory: {e}")

    # Permission Test: Try to write a tiny file to verify OS access to the folder
    try:
        test_path = os.path.join(TEMP_DIR, '.write_test')
        with open(test_path, 'w') as f:
            f.write('test')
        os.remove(test_path)
    except Exception as e:
        print(f"\nFATAL: Folder permission error in '{TEMP_DIR}'.")
        print(f"macOS often restricts access to 'Documents' folders.")
        print(f"Try granting your Terminal 'Full Disk Access' in System Settings.")
        print(f"Original Error: {e}")
        return

    print(f"Searching for data in '{INPUT_DIR}'...")

    # 1. Look for direct files first
    for name in CANDIDATE_NAMES:
        path = os.path.join(INPUT_DIR, name)
        if os.path.exists(path):
            source_file = path
            break
    
    # 2. Look for ZIP archive if no direct file found
    if not source_file:
        try:
            if os.path.exists(INPUT_DIR):
                files = os.listdir(INPUT_DIR)
                zip_files = [f for f in files if f.lower().endswith('.zip')]
                if zip_files:
                    zip_path = os.path.join(INPUT_DIR, zip_files[0])
                    print(f"ZIP detected: {zip_path}")
                    zip_archive = zipfile.ZipFile(zip_path, 'r')
                    
                    zip_contents = zip_archive.namelist()
                    for name in CANDIDATE_NAMES:
                        if name in zip_contents:
                            source_file = name
                            is_zip = True
                            break
                    
                    if not source_file:
                        potential = [f for f in zip_contents if 'names' in f.lower() or 'checklist' in f.lower()]
                        if potential:
                            source_file = sorted(potential, key=lambda x: zip_archive.getinfo(x).file_size, reverse=True)[0]
                            is_zip = True
            else:
                print(f"Warning: Directory '{INPUT_DIR}' does not exist.")
        except Exception as e:
            print(f"Error reading ZIP: {e}")

    if not source_file:
        print(f"Error: No WCVP data found in '{INPUT_DIR}'.")
        return

    print(f"Processing source: {source_file} {'(from ZIP)' if is_zip else ''}")
    print(f"Generating: {OUTPUT_FILENAME}")

    # PRE-CLEAN: Remove existing file to release any OS locks
    if os.path.exists(OUTPUT_FILENAME):
        try:
            # On macOS, sometimes files get the "uchg" (immutable) flag
            if sys.platform == 'darwin':
                try: os.system(f'chflags nouchg "{OUTPUT_FILENAME}"')
                except: pass
            os.remove(OUTPUT_FILENAME)
        except Exception as e:
            print(f"Warning: Could not remove existing output file: {e}")
            # If we can't remove it, we try to overwrite it anyway, but likely to fail

    try:
        # Increase field size limit for safety
        csv.field_size_limit(sys.maxsize)
        row_count = 0
        
        if is_zip:
            infile = io.TextIOWrapper(zip_archive.open(source_file), encoding='utf-8', errors='replace')
        else:
            infile = open(source_file, mode='r', encoding='utf-8', errors='replace')

        # We use a context manager to ensure handles are closed even on error
        with infile, open(OUTPUT_FILENAME, mode='w', encoding='utf-8', newline='') as outfile:
            reader = csv.reader(infile, delimiter='|', quoting=csv.QUOTE_NONE)
            writer = csv.writer(outfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            
            for row in reader:
                writer.writerow(row)
                row_count += 1
                if row_count % 100000 == 0:
                    print(f"  Processed {row_count:,} rows...")
            
            outfile.flush()
            os.fsync(outfile.fileno())

        print(f"Success! Converted {row_count:,} rows.")

    except Exception as e:
        print(f"\nFATAL ERROR: {str(e)}")
        if "Operation not permitted" in str(e):
            print("\nðŸ’¡ macOS TROUBLESHOOTING:")
            print("1. Close any apps that might have the CSV open (Excel, Numbers, VS Code).")
            print("2. Ensure Terminal/iTerm has permission to access your Documents folder.")
    finally:
        if zip_archive:
            zip_archive.close()

if __name__ == "__main__":
    convert_wcvp()
