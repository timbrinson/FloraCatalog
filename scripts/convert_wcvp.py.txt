
import csv
import sys
import os
import zipfile
import io
import errno

def convert_wcvp():
    # Detect Project Root (one level up from this script in /scripts)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    root_dir = os.path.dirname(script_dir)
    
    # Configuration using Absolute Paths
    # macOS protects Documents, Desktop, and Downloads folders.
    INPUT_DIR = os.path.join(root_dir, 'data', 'input')
    TEMP_DIR = os.path.join(root_dir, 'data', 'temp')
    OUTPUT_FILENAME = os.path.join(TEMP_DIR, 'wcvp_names_clean.csv')
    
    # Filenames typically found inside the Kew ZIP or provided directly
    CANDIDATE_NAMES = ['wcvp_names.csv', 'wcvp_names.txt', 'checklist_names.txt']

    source_file = None
    is_zip = False
    zip_archive = None

    print(f"Project Root: {root_dir}")

    # Ensure temp directory exists
    if not os.path.exists(TEMP_DIR):
        try:
            os.makedirs(TEMP_DIR, exist_ok=True)
            print(f"Created directory: {TEMP_DIR}")
        except Exception as e:
            print(f"Error creating temp directory: {e}")

    # Permission Test: Try to write a tiny file to verify OS access to the folder
    test_path = os.path.join(TEMP_DIR, '.write_test')
    try:
        # Create directory if missing before test
        if not os.path.exists(TEMP_DIR):
            os.makedirs(TEMP_DIR, exist_ok=True)
            
        with open(test_path, 'w') as f:
            f.write('test')
        os.remove(test_path)
    except OSError as e:
        if e.errno == errno.EPERM:
            print("\n" + "!"*65)
            print(" CRITICAL: macOS PERMISSION ERROR DETECTED")
            print("!"*65)
            print(f" Location: {TEMP_DIR}")
            print("\n Your project is located in a protected macOS folder (Documents).")
            print(" macOS is blocking Python from writing to this directory.")
            print("\n HOW TO FIX:")
            print(" 1. Open 'System Settings' -> 'Privacy & Security'.")
            print(" 2. Select 'Full Disk Access'.")
            print(" 3. Click the '+' button.")
            print(" 4. Add your Terminal app (Terminal, iTerm, or VS Code).")
            print(" 5. Ensure the toggle for your Terminal is ON.")
            print(" 6. Restart your Terminal window and run the script again.")
            print("!"*65 + "\n")
            sys.exit(1)
        else:
            print(f"\nFATAL: Unexpected folder error in '{TEMP_DIR}': {e}")
            sys.exit(1)

    print(f"Searching for data in '{INPUT_DIR}'...")

    # 1. Look for direct files first
    for name in CANDIDATE_NAMES:
        path = os.path.join(INPUT_DIR, name)
        if os.path.exists(path):
            source_file = path
            break
    
    # 2. Look for ZIP archive if no direct file found
    if not source_file:
        try:
            if os.path.exists(INPUT_DIR):
                files = os.listdir(INPUT_DIR)
                zip_files = [f for f in files if f.lower().endswith('.zip')]
                if zip_files:
                    zip_path = os.path.join(INPUT_DIR, zip_files[0])
                    print(f"ZIP detected: {zip_path}")
                    zip_archive = zipfile.ZipFile(zip_path, 'r')
                    
                    zip_contents = zip_archive.namelist()
                    for name in CANDIDATE_NAMES:
                        if name in zip_contents:
                            source_file = name
                            is_zip = True
                            break
                    
                    if not source_file:
                        potential = [f for f in zip_contents if 'names' in f.lower() or 'checklist' in f.lower()]
                        if potential:
                            source_file = sorted(potential, key=lambda x: zip_archive.getinfo(x).file_size, reverse=True)[0]
                            is_zip = True
            else:
                print(f"Warning: Directory '{INPUT_DIR}' does not exist.")
        except Exception as e:
            print(f"Error reading ZIP: {e}")

    if not source_file:
        print(f"Error: No WCVP data found in '{INPUT_DIR}'.")
        sys.exit(1)

    print(f"Processing source: {source_file} {'(from ZIP)' if is_zip else ''}")
    print(f"Generating: {OUTPUT_FILENAME}")

    # PRE-CLEAN: Remove existing file to release any OS locks
    if os.path.exists(OUTPUT_FILENAME):
        try:
            if sys.platform == 'darwin':
                try: os.system(f'chflags nouchg "{OUTPUT_FILENAME}"')
                except: pass
            os.remove(OUTPUT_FILENAME)
        except Exception as e:
            print(f"Warning: Could not remove existing output file: {e}")

    try:
        csv.field_size_limit(sys.maxsize)
        row_count = 0
        
        if is_zip:
            infile = io.TextIOWrapper(zip_archive.open(source_file), encoding='utf-8', errors='replace')
        else:
            infile = open(source_file, mode='r', encoding='utf-8', errors='replace')

        with infile, open(OUTPUT_FILENAME, mode='w', encoding='utf-8', newline='') as outfile:
            reader = csv.reader(infile, delimiter='|', quoting=csv.QUOTE_NONE)
            writer = csv.writer(outfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            
            for row in reader:
                writer.writerow(row)
                row_count += 1
                if row_count % 100000 == 0:
                    print(f"  Processed {row_count:,} rows...")
            
            outfile.flush()
            os.fsync(outfile.fileno())

        print(f"Success! Converted {row_count:,} rows.")

    except Exception as e:
        print(f"\nFATAL ERROR: {str(e)}")
        if "Operation not permitted" in str(e):
            print("\nðŸ’¡ macOS TROUBLESHOOTING:")
            print("1. Close any apps that might have the CSV open (Excel, Numbers, VS Code).")
            print("2. Ensure Terminal/iTerm has permission to access your Documents folder.")
    finally:
        if zip_archive:
            zip_archive.close()

if __name__ == "__main__":
    convert_wcvp()
